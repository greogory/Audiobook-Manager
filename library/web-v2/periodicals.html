<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reading Room - Periodicals</title>
    <link rel="stylesheet" href="css/periodicals.css">
    <!-- HTMX for dynamic content without full JS framework -->
    <script src="https://unpkg.com/htmx.org@2.0.4" integrity="sha384-HGfztofotfshcF7+8n44JQL2oJmowVChPTg48S+jvZoztPfvwD79OC/LTtG6dMp+" crossorigin="anonymous"></script>
</head>
<body>
    <!-- Header -->
    <header class="reading-room-header">
        <div class="header-content">
            <div class="title-section">
                <a href="index.html" class="back-link" title="Return to Library">
                    <span class="back-arrow">‚Üê</span>
                </a>
                <h1 class="room-title">Reading Room</h1>
                <p class="room-subtitle">Periodicals, Podcasts & More</p>
            </div>

            <!-- Sync Status & Refresh Button -->
            <div class="sync-controls">
                <div class="sync-status" id="sync-status" title="Last sync status">
                    <span class="sync-icon">‚ü≥</span>
                    <span class="sync-text">Idle</span>
                </div>
                <button class="refresh-btn" id="refresh-btn"
                        title="Refresh periodicals index from Audible">
                    <span class="refresh-icon">‚Üª</span>
                    <span class="refresh-text">Sync Now</span>
                </button>
            </div>
        </div>

        <!-- Category Tabs -->
        <nav class="category-tabs">
            <button class="category-tab active" data-category="all" title="Show all periodicals">All</button>
            <button class="category-tab" data-category="podcast" title="Podcasts and audio series">Podcasts</button>
            <button class="category-tab" data-category="news" title="Newspapers and news digests">News</button>
            <button class="category-tab" data-category="meditation" title="Meditation and sleep content">Meditation</button>
            <button class="category-tab" data-category="other" title="Other periodical content">Other</button>
        </nav>
    </header>

    <!-- Main Content -->
    <main class="reading-room-main">
        <!-- Left Panel: Parent List -->
        <aside class="parent-list-panel">
            <div class="panel-header">
                <h2>Publications</h2>
                <span class="parent-count" id="parent-count">-</span>
            </div>

            <div class="parent-list" id="parent-list">
                <div class="loading-indicator">Loading...</div>
            </div>
        </aside>

        <!-- Right Panel: Episode List -->
        <section class="episode-list-panel">
            <div class="panel-header">
                <div class="episode-header-left">
                    <h2 id="episode-panel-title">Select a publication</h2>
                    <span class="episode-count" id="episode-count"></span>
                </div>
                <div class="episode-header-right">
                    <button class="select-all-btn" id="select-all-btn" title="Select all new episodes" disabled>
                        Select All New
                    </button>
                </div>
            </div>

            <div class="episode-list" id="episode-list">
                <div class="empty-state">
                    <span class="empty-icon">üì∞</span>
                    <p>Select a publication from the left to browse episodes</p>
                </div>
            </div>

            <!-- Bulk Actions Footer -->
            <div class="bulk-actions" id="bulk-actions" style="display: none;">
                <div class="selected-count">
                    <span id="selected-count">0</span> selected
                </div>
                <button class="download-btn" id="download-selected-btn"
                        title="Queue selected episodes for download" disabled>
                    <span class="download-icon">‚Üì</span>
                    Download Selected
                </button>
            </div>
        </section>
    </main>

    <!-- Download Queue Toast -->
    <div class="queue-toast" id="queue-toast" style="display: none;">
        <div class="queue-toast-content">
            <span class="queue-icon">üì•</span>
            <span class="queue-text" id="queue-text">0 items in download queue</span>
            <button class="queue-close" id="queue-close" title="Dismiss">√ó</button>
        </div>
    </div>

    <script>
        // ========================================
        // Periodicals Reading Room - Secure JS
        // Uses safe DOM methods (no innerHTML)
        // ========================================

        const API_BASE = '/api/v1/periodicals';
        let currentCategory = 'all';
        let currentParentAsin = null;
        let currentParentTitle = '';
        let selectedEpisodes = new Set();
        let sseConnection = null;

        // ========================================
        // Safe DOM Creation Utilities
        // ========================================
        function createElement(tag, attrs = {}, children = []) {
            const el = document.createElement(tag);
            for (const [key, value] of Object.entries(attrs)) {
                if (key === 'className') {
                    el.className = value;
                } else if (key === 'textContent') {
                    el.textContent = value;
                } else if (key.startsWith('data')) {
                    el.dataset[key.slice(4).toLowerCase()] = value;
                } else if (key.startsWith('on') && typeof value === 'function') {
                    el.addEventListener(key.slice(2).toLowerCase(), value);
                } else {
                    el.setAttribute(key, value);
                }
            }
            children.forEach(child => {
                if (typeof child === 'string') {
                    el.appendChild(document.createTextNode(child));
                } else if (child) {
                    el.appendChild(child);
                }
            });
            return el;
        }

        function clearElement(el) {
            while (el.firstChild) {
                el.removeChild(el.firstChild);
            }
        }

        // ========================================
        // SSE Connection for Sync Status
        // ========================================
        function connectSSE() {
            if (sseConnection) sseConnection.close();

            sseConnection = new EventSource(API_BASE + '/sync/status');

            sseConnection.onmessage = function(event) {
                try {
                    const data = JSON.parse(event.data);
                    updateSyncStatus(data);
                } catch (e) {
                    console.error('SSE parse error:', e);
                }
            };

            sseConnection.onerror = function() {
                updateSyncStatus({ status: 'disconnected' });
                setTimeout(connectSSE, 5000);
            };
        }

        function updateSyncStatus(data) {
            const statusEl = document.getElementById('sync-status');
            const textEl = statusEl.querySelector('.sync-text');
            const iconEl = statusEl.querySelector('.sync-icon');
            const refreshBtn = document.getElementById('refresh-btn');

            statusEl.classList.remove('syncing', 'error', 'success');

            switch (data.status) {
                case 'running':
                    statusEl.classList.add('syncing');
                    iconEl.textContent = '‚ü≥';
                    textEl.textContent = 'Syncing ' + (data.processed || 0) + '/' + (data.total || '?') + '...';
                    refreshBtn.disabled = true;
                    break;
                case 'completed':
                    statusEl.classList.add('success');
                    iconEl.textContent = '‚úì';
                    textEl.textContent = (data.new || 0) + ' new episodes';
                    refreshBtn.disabled = false;
                    loadParentList();
                    break;
                case 'failed':
                    statusEl.classList.add('error');
                    iconEl.textContent = '‚úó';
                    textEl.textContent = 'Sync failed';
                    refreshBtn.disabled = false;
                    break;
                default:
                    iconEl.textContent = '‚ü≥';
                    textEl.textContent = 'Idle';
                    refreshBtn.disabled = false;
            }
        }

        // ========================================
        // Sync Trigger (On-Demand Refresh)
        // ========================================
        async function triggerSync() {
            const refreshBtn = document.getElementById('refresh-btn');
            refreshBtn.disabled = true;

            try {
                const response = await fetch(API_BASE + '/sync/trigger', { method: 'POST' });
                if (response.ok) {
                    updateSyncStatus({ status: 'running', processed: 0, total: '?' });
                }
            } catch (error) {
                console.error('Sync trigger failed:', error);
                refreshBtn.disabled = false;
            }
        }

        // ========================================
        // Parent List Loading & Rendering
        // ========================================
        async function loadParentList() {
            const container = document.getElementById('parent-list');
            clearElement(container);
            container.appendChild(createElement('div', { className: 'loading-indicator', textContent: 'Loading...' }));

            try {
                const response = await fetch(API_BASE);
                const data = await response.json();
                renderParentList(data.periodicals || []);
            } catch (error) {
                clearElement(container);
                container.appendChild(createEmptyState('‚ö†Ô∏è', 'Failed to load periodicals'));
            }
        }

        function renderParentList(periodicals) {
            const container = document.getElementById('parent-list');
            const countEl = document.getElementById('parent-count');

            // Filter by current category
            if (currentCategory !== 'all') {
                periodicals = periodicals.filter(function(p) { return p.category === currentCategory; });
            }

            countEl.textContent = String(periodicals.length);
            clearElement(container);

            if (periodicals.length === 0) {
                container.appendChild(createEmptyState('üì≠', 'No periodicals in this category'));
                return;
            }

            periodicals.forEach(function(p) {
                container.appendChild(createParentCard(p));
            });
        }

        function createParentCard(p) {
            const coverContent = p.cover_url
                ? createElement('img', { src: p.cover_url, alt: '', loading: 'lazy' })
                : createElement('span', { className: 'no-cover', textContent: 'üìª' });

            const badges = [];
            badges.push(createElement('span', { className: 'episode-badge', textContent: p.episode_count + ' eps' }));
            if (p.downloaded_count > 0) {
                badges.push(createElement('span', { className: 'downloaded-badge', textContent: p.downloaded_count + ' ‚Üì' }));
            }
            if (p.queued_count > 0) {
                badges.push(createElement('span', { className: 'queued-badge', textContent: p.queued_count + ' ‚è≥' }));
            }

            const card = createElement('button', {
                className: 'parent-card' + (p.parent_asin === currentParentAsin ? ' active' : ''),
                dataAsin: p.parent_asin,
                title: p.title + ' - ' + p.episode_count + ' episodes',
                onClick: function() { selectParent(p.parent_asin, p.title); }
            }, [
                createElement('div', { className: 'parent-cover' }, [coverContent]),
                createElement('div', { className: 'parent-info' }, [
                    createElement('span', { className: 'parent-title', textContent: p.title }),
                    createElement('span', { className: 'parent-meta' }, badges)
                ])
            ]);

            return card;
        }

        function createEmptyState(icon, message) {
            return createElement('div', { className: 'empty-state' }, [
                createElement('span', { className: 'empty-icon', textContent: icon }),
                createElement('p', { textContent: message })
            ]);
        }

        // ========================================
        // Episode List Loading & Rendering
        // ========================================
        async function selectParent(asin, title) {
            currentParentAsin = asin;
            currentParentTitle = title;
            selectedEpisodes.clear();
            updateSelectionUI();

            // Update active state in parent list
            document.querySelectorAll('.parent-card').forEach(function(card) {
                card.classList.toggle('active', card.dataset.asin === asin);
            });

            // Update episode panel header
            document.getElementById('episode-panel-title').textContent = title;
            document.getElementById('select-all-btn').disabled = false;

            // Load episodes
            const container = document.getElementById('episode-list');
            clearElement(container);
            container.appendChild(createElement('div', { className: 'loading-indicator', textContent: 'Loading episodes...' }));

            try {
                const response = await fetch(API_BASE + '/' + asin + '?per_page=100');
                const data = await response.json();
                renderEpisodeList(data);
            } catch (error) {
                clearElement(container);
                container.appendChild(createEmptyState('‚ö†Ô∏è', 'Failed to load episodes'));
            }
        }

        function renderEpisodeList(data) {
            const container = document.getElementById('episode-list');
            const countEl = document.getElementById('episode-count');

            countEl.textContent = data.total + ' episodes';
            clearElement(container);

            if (!data.episodes || data.episodes.length === 0) {
                container.appendChild(createEmptyState('üì≠', 'No episodes available'));
                return;
            }

            data.episodes.forEach(function(ep) {
                container.appendChild(createEpisodeCard(ep));
            });

            document.getElementById('bulk-actions').style.display = 'flex';
        }

        function createEpisodeCard(ep) {
            const isDisabled = ep.is_downloaded || ep.download_requested;

            const checkbox = createElement('input', {
                type: 'checkbox',
                className: 'episode-checkbox',
                dataAsin: ep.child_asin
            });
            if (isDisabled) checkbox.disabled = true;
            if (ep.download_requested) checkbox.checked = true;
            checkbox.addEventListener('change', function() {
                toggleEpisode(ep.child_asin, this.checked);
            });

            const statusIcons = [];
            if (ep.is_downloaded) {
                statusIcons.push(createElement('span', { className: 'status-downloaded', title: 'Downloaded', textContent: '‚úì' }));
            }
            if (ep.download_requested && !ep.is_downloaded) {
                statusIcons.push(createElement('span', { className: 'status-queued', title: 'Queued', textContent: '‚è≥' }));
            }

            const metaParts = [];
            if (ep.runtime_minutes) metaParts.push(ep.runtime_minutes + ' min');
            if (ep.release_date) metaParts.push(formatDate(ep.release_date));

            const card = createElement('label', {
                className: 'episode-card' + (ep.is_downloaded ? ' downloaded' : '') + (ep.download_requested ? ' queued' : ''),
                title: ep.episode_title || ('Episode ' + ep.episode_number)
            }, [
                checkbox,
                createElement('div', { className: 'episode-info' }, [
                    createElement('span', { className: 'episode-number', textContent: ep.episode_number || '‚Äî' }),
                    createElement('span', { className: 'episode-title', textContent: ep.episode_title || 'Untitled' }),
                    createElement('span', { className: 'episode-meta', textContent: metaParts.join(' ‚Ä¢ ') })
                ]),
                createElement('div', { className: 'episode-status' }, statusIcons)
            ]);

            return card;
        }

        // ========================================
        // Selection Management
        // ========================================
        function toggleEpisode(asin, checked) {
            if (checked) {
                selectedEpisodes.add(asin);
            } else {
                selectedEpisodes.delete(asin);
            }
            updateSelectionUI();
        }

        function selectAllNew() {
            document.querySelectorAll('.episode-checkbox:not(:disabled)').forEach(function(cb) {
                cb.checked = true;
                selectedEpisodes.add(cb.dataset.asin);
            });
            updateSelectionUI();
        }

        function updateSelectionUI() {
            const count = selectedEpisodes.size;
            document.getElementById('selected-count').textContent = String(count);
            document.getElementById('download-selected-btn').disabled = count === 0;
        }

        // ========================================
        // Download Queue
        // ========================================
        async function downloadSelected() {
            if (selectedEpisodes.size === 0) return;

            const btn = document.getElementById('download-selected-btn');
            btn.disabled = true;
            const btnIcon = btn.querySelector('.download-icon');
            const originalIcon = btnIcon.textContent;
            btnIcon.textContent = '‚è≥';

            try {
                const response = await fetch(API_BASE + '/download', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ asins: Array.from(selectedEpisodes) })
                });

                const data = await response.json();
                showQueueToast(data.queued + ' episodes queued for download', false);

                // Refresh episode list
                if (currentParentAsin) {
                    selectParent(currentParentAsin, currentParentTitle);
                }
            } catch (error) {
                showQueueToast('Failed to queue downloads', true);
            }

            btnIcon.textContent = originalIcon;
        }

        function showQueueToast(message, isError) {
            const toast = document.getElementById('queue-toast');
            const text = document.getElementById('queue-text');
            text.textContent = message;
            toast.classList.toggle('error', isError);
            toast.style.display = 'flex';

            setTimeout(function() {
                toast.style.display = 'none';
            }, 5000);
        }

        // ========================================
        // Category Tabs
        // ========================================
        document.querySelectorAll('.category-tab').forEach(function(tab) {
            tab.addEventListener('click', function() {
                document.querySelectorAll('.category-tab').forEach(function(t) {
                    t.classList.remove('active');
                });
                tab.classList.add('active');
                currentCategory = tab.dataset.category;
                loadParentList();
            });
        });

        // ========================================
        // Event Listeners
        // ========================================
        document.getElementById('refresh-btn').addEventListener('click', triggerSync);
        document.getElementById('select-all-btn').addEventListener('click', selectAllNew);
        document.getElementById('download-selected-btn').addEventListener('click', downloadSelected);
        document.getElementById('queue-close').addEventListener('click', function() {
            document.getElementById('queue-toast').style.display = 'none';
        });

        // ========================================
        // Utilities
        // ========================================
        function formatDate(dateStr) {
            if (!dateStr) return '';
            try {
                const date = new Date(dateStr);
                return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
            } catch (e) {
                return '';
            }
        }

        // ========================================
        // Initialize
        // ========================================
        document.addEventListener('DOMContentLoaded', function() {
            connectSSE();
            loadParentList();
        });
    </script>
</body>
</html>
