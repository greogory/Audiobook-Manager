<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reading Room - Periodicals</title>
    <link rel="stylesheet" href="css/periodicals.css">
</head>
<body>
    <!-- Header -->
    <header class="reading-room-header">
        <div class="header-content">
            <div class="title-section">
                <a href="index.html" class="back-link" title="Return to Library">
                    <span class="back-arrow">‚Üê</span>
                </a>
                <h1 class="room-title">Reading Room</h1>
                <p class="room-subtitle">Periodicals, Podcasts & More</p>
            </div>

            <!-- Sync Status & Refresh Button -->
            <div class="sync-controls">
                <div class="sync-status" id="sync-status" title="Last sync status">
                    <span class="sync-icon">‚ü≥</span>
                    <span class="sync-text">Idle</span>
                </div>
                <button class="refresh-btn" id="refresh-btn"
                        title="Refresh periodicals index from Audible">
                    <span class="refresh-icon">‚Üª</span>
                    <span class="refresh-text">Sync Now</span>
                </button>
            </div>
        </div>

        <!-- Category Tabs -->
        <nav class="category-tabs">
            <button class="category-tab active" data-category="all" title="Show all periodicals">All</button>
            <button class="category-tab" data-category="podcast" title="Podcasts and audio series">Podcasts</button>
            <button class="category-tab" data-category="news" title="Newspapers and news digests">News</button>
            <button class="category-tab" data-category="meditation" title="Meditation and sleep content">Meditation</button>
            <button class="category-tab" data-category="other" title="Other periodical content">Other</button>
        </nav>
    </header>

    <!-- Main Content -->
    <main class="reading-room-main">
        <!-- Left Panel: Periodicals List -->
        <aside class="parent-list-panel">
            <div class="panel-header">
                <h2>Publications</h2>
                <span class="parent-count" id="parent-count">-</span>
            </div>
            <div class="sort-controls">
                <span class="sort-label">Sort:</span>
                <button class="sort-btn active" data-sort="alpha" data-panel="parent" title="Sort alphabetically">A-Z</button>
                <button class="sort-btn" data-sort="date" data-panel="parent" title="Sort by date (newest first)">Date</button>
                <button class="sort-btn" data-sort="episodes" data-panel="parent" title="Sort by episode count">Episodes</button>
            </div>

            <div class="parent-list" id="parent-list">
                <div class="loading-indicator">Loading...</div>
            </div>
        </aside>

        <!-- Right Panel: Item Details -->
        <section class="episode-list-panel">
            <div class="panel-header">
                <div class="episode-header-left">
                    <h2 id="episode-panel-title">Select a publication</h2>
                    <span class="episode-count" id="episode-count"></span>
                </div>
                <div class="sort-controls episode-sort" id="episode-sort-controls" style="display: none;">
                    <span class="sort-label">Sort:</span>
                    <button class="sort-btn active" data-sort="date-desc" data-panel="episode" title="Newest first">Newest</button>
                    <button class="sort-btn" data-sort="date-asc" data-panel="episode" title="Oldest first">Oldest</button>
                    <button class="sort-btn" data-sort="alpha" data-panel="episode" title="Sort alphabetically">A-Z</button>
                </div>
            </div>

            <div class="episode-list" id="episode-list">
                <div class="empty-state">
                    <span class="empty-icon">üì∞</span>
                    <p>Select a publication from the left to view details</p>
                </div>
            </div>
        </section>
    </main>

    <!-- Download Queue Toast -->
    <div class="queue-toast" id="queue-toast" style="display: none;">
        <div class="queue-toast-content">
            <span class="queue-icon">üì•</span>
            <span class="queue-text" id="queue-text">Item queued for download</span>
            <button class="queue-close" id="queue-close" title="Dismiss">√ó</button>
        </div>
    </div>

    <script>
        // ========================================
        // Periodicals Reading Room - New Flat Schema
        // Each periodical is a standalone item (no episodes)
        // ========================================

        const API_BASE = '/api/v1/periodicals';
        let currentCategory = 'all';
        let currentAsin = null;
        let sseConnection = null;

        // Sorting state
        let parentSortBy = 'alpha';  // 'alpha', 'date', 'episodes'
        let episodeSortBy = 'date-desc';  // 'date-desc', 'date-asc', 'alpha'
        let cachedParents = [];  // Cache for re-sorting without refetch
        let cachedEpisodes = [];  // Cache for re-sorting without refetch

        // Sort comparison functions
        function sortParents(parents, sortBy) {
            return [...parents].sort((a, b) => {
                switch (sortBy) {
                    case 'alpha':
                        return (a.title || '').localeCompare(b.title || '');
                    case 'date':
                        // Newest first
                        const dateA = a.release_date || '1900-01-01';
                        const dateB = b.release_date || '1900-01-01';
                        return dateB.localeCompare(dateA);
                    case 'episodes':
                        return (b.episode_count || 0) - (a.episode_count || 0);
                    default:
                        return 0;
                }
            });
        }

        function sortEpisodes(episodes, sortBy) {
            return [...episodes].sort((a, b) => {
                switch (sortBy) {
                    case 'alpha':
                        return (a.title || '').localeCompare(b.title || '');
                    case 'date-desc':
                        // Newest first
                        const dateA = a.release_date || '1900-01-01';
                        const dateB = b.release_date || '1900-01-01';
                        return dateB.localeCompare(dateA);
                    case 'date-asc':
                        // Oldest first
                        const dateC = a.release_date || '1900-01-01';
                        const dateD = b.release_date || '1900-01-01';
                        return dateC.localeCompare(dateD);
                    default:
                        return 0;
                }
            });
        }

        // ========================================
        // Safe DOM Creation Utilities
        // ========================================
        function createElement(tag, attrs = {}, children = []) {
            const el = document.createElement(tag);
            for (const [key, value] of Object.entries(attrs)) {
                if (key === 'className') {
                    el.className = value;
                } else if (key === 'textContent') {
                    el.textContent = value;
                } else if (key.startsWith('data')) {
                    el.dataset[key.slice(4).toLowerCase()] = value;
                } else if (key.startsWith('on') && typeof value === 'function') {
                    el.addEventListener(key.slice(2).toLowerCase(), value);
                } else {
                    el.setAttribute(key, value);
                }
            }
            children.forEach(child => {
                if (typeof child === 'string') {
                    el.appendChild(document.createTextNode(child));
                } else if (child) {
                    el.appendChild(child);
                }
            });
            return el;
        }

        function clearElement(el) {
            while (el.firstChild) {
                el.removeChild(el.firstChild);
            }
        }

        // ========================================
        // SSE Connection for Sync Status
        // ========================================
        function connectSSE() {
            if (sseConnection) sseConnection.close();

            sseConnection = new EventSource(API_BASE + '/sync/status');

            sseConnection.onmessage = function(event) {
                try {
                    const data = JSON.parse(event.data);
                    updateSyncStatus(data);
                } catch (e) {
                    console.error('SSE parse error:', e);
                }
            };

            sseConnection.onerror = function() {
                updateSyncStatus({ status: 'disconnected' });
                setTimeout(connectSSE, 5000);
            };
        }

        function updateSyncStatus(data) {
            const statusEl = document.getElementById('sync-status');
            const textEl = statusEl.querySelector('.sync-text');
            const iconEl = statusEl.querySelector('.sync-icon');
            const refreshBtn = document.getElementById('refresh-btn');

            statusEl.classList.remove('syncing', 'error', 'success');

            switch (data.status) {
                case 'running':
                    statusEl.classList.add('syncing');
                    iconEl.textContent = '‚ü≥';
                    textEl.textContent = 'Syncing ' + (data.processed || 0) + '/' + (data.total || '?') + '...';
                    refreshBtn.disabled = true;
                    break;
                case 'completed':
                    statusEl.classList.add('success');
                    iconEl.textContent = '‚úì';
                    textEl.textContent = (data.new || 0) + ' new items';
                    refreshBtn.disabled = false;
                    loadPeriodicalsList();
                    break;
                case 'failed':
                    statusEl.classList.add('error');
                    iconEl.textContent = '‚úó';
                    textEl.textContent = 'Sync failed';
                    refreshBtn.disabled = false;
                    break;
                default:
                    iconEl.textContent = '‚ü≥';
                    textEl.textContent = 'Idle';
                    refreshBtn.disabled = false;
            }
        }

        // ========================================
        // Sync Trigger (On-Demand Refresh)
        // ========================================
        async function triggerSync() {
            const refreshBtn = document.getElementById('refresh-btn');
            refreshBtn.disabled = true;

            try {
                const response = await fetch(API_BASE + '/sync/trigger', { method: 'POST' });
                if (response.ok) {
                    updateSyncStatus({ status: 'running', processed: 0, total: '?' });
                }
            } catch (error) {
                console.error('Sync trigger failed:', error);
                refreshBtn.disabled = false;
            }
        }

        // ========================================
        // Periodicals List Loading & Rendering (Tree Structure)
        // ========================================
        async function loadPeriodicalsList() {
            const container = document.getElementById('parent-list');
            clearElement(container);
            container.appendChild(createElement('div', { className: 'loading-indicator', textContent: 'Loading...' }));

            try {
                // Load PARENTS only (series/shows) - not individual episodes
                let url = API_BASE + '/parents';
                if (currentCategory !== 'all') {
                    url += '?category=' + encodeURIComponent(currentCategory);
                }
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error('HTTP ' + response.status + ': ' + response.statusText);
                }
                const data = await response.json();
                cachedParents = data.parents || [];  // Cache for re-sorting
                renderPeriodicalsList(cachedParents);
            } catch (error) {
                console.error('Failed to load periodicals:', error);
                clearElement(container);
                container.appendChild(createEmptyState('‚ö†Ô∏è', 'Failed to load periodicals'));
            }
        }

        function renderPeriodicalsList(parents) {
            const container = document.getElementById('parent-list');
            const countEl = document.getElementById('parent-count');

            // Apply current sort
            const sortedParents = sortParents(parents, parentSortBy);

            countEl.textContent = String(sortedParents.length);
            clearElement(container);

            if (sortedParents.length === 0) {
                container.appendChild(createEmptyState('üì≠', 'No series in this category'));
                return;
            }

            sortedParents.forEach(function(p) {
                container.appendChild(createPeriodicalCard(p));
            });
        }

        function createPeriodicalCard(p) {
            const coverContent = p.cover_url
                ? createElement('img', { src: p.cover_url, alt: '', loading: 'lazy' })
                : createElement('span', { className: 'no-cover', textContent: 'üìª' });

            // Status badges
            const badges = [];

            // Episode count badge (for parent series)
            if (p.episode_count && p.episode_count > 0) {
                badges.push(createElement('span', {
                    className: 'episode-count-badge',
                    textContent: p.episode_count + ' episode' + (p.episode_count !== 1 ? 's' : ''),
                    title: p.episode_count + ' episodes in this series'
                }));
            }

            if (p.content_type) {
                badges.push(createElement('span', {
                    className: 'type-badge',
                    textContent: p.content_type
                }));
            }
            if (p.is_downloaded) {
                badges.push(createElement('span', {
                    className: 'downloaded-badge',
                    textContent: '‚úì Downloaded'
                }));
            }
            if (p.download_requested && !p.is_downloaded) {
                badges.push(createElement('span', {
                    className: 'queued-badge',
                    textContent: '‚è≥ Queued'
                }));
            }

            const card = createElement('button', {
                className: 'parent-card' + (p.asin === currentAsin ? ' active' : ''),
                dataAsin: p.asin,
                title: p.title + (p.episode_count ? ' (' + p.episode_count + ' episodes)' : ''),
                onClick: function() { selectPeriodical(p.asin, p.episode_count || 0); }
            }, [
                createElement('div', { className: 'parent-cover' }, [coverContent]),
                createElement('div', { className: 'parent-info' }, [
                    createElement('span', { className: 'parent-title', textContent: p.title }),
                    createElement('span', { className: 'parent-author', textContent: p.author || '' }),
                    createElement('span', { className: 'parent-meta' }, badges)
                ])
            ]);

            return card;
        }

        function createEmptyState(icon, message) {
            return createElement('div', { className: 'empty-state' }, [
                createElement('span', { className: 'empty-icon', textContent: icon }),
                createElement('p', { textContent: message })
            ]);
        }

        // ========================================
        // Periodical Details View (Tree Structure)
        // ========================================
        async function selectPeriodical(asin, episodeCount) {
            currentAsin = asin;

            // Update active state in list
            document.querySelectorAll('.parent-card').forEach(function(card) {
                card.classList.toggle('active', card.dataset.asin === asin);
            });

            const container = document.getElementById('episode-list');
            const titleEl = document.getElementById('episode-panel-title');
            const countEl = document.getElementById('episode-count');

            clearElement(container);
            container.appendChild(createElement('div', { className: 'loading-indicator', textContent: 'Loading...' }));

            try {
                // Load parent details first
                const parentResponse = await fetch(API_BASE + '/' + encodeURIComponent(asin));
                if (!parentResponse.ok) {
                    throw new Error('HTTP ' + parentResponse.status);
                }
                const parentData = await parentResponse.json();

                // Update header
                titleEl.textContent = parentData.title;

                // If parent has episodes, load them
                if (episodeCount > 0) {
                    countEl.textContent = episodeCount + ' episode' + (episodeCount !== 1 ? 's' : '');
                    const episodesResponse = await fetch(API_BASE + '/' + encodeURIComponent(asin) + '/episodes?sort=release_date&order=desc');
                    if (episodesResponse.ok) {
                        const episodesData = await episodesResponse.json();
                        renderSeriesWithEpisodes(parentData, episodesData.episodes || []);
                    } else {
                        renderPeriodicalDetails(parentData);
                    }
                } else {
                    // No episodes - just show parent details
                    countEl.textContent = parentData.content_type || 'Episode';
                    renderPeriodicalDetails(parentData);
                }
            } catch (error) {
                console.error('Failed to load details:', error);
                clearElement(container);
                container.appendChild(createEmptyState('‚ö†Ô∏è', 'Failed to load details'));
            }
        }

        // Store current parent for queueAllEpisodes
        let currentParent = null;

        function renderSeriesWithEpisodes(parent, episodes) {
            const container = document.getElementById('episode-list');
            const sortControls = document.getElementById('episode-sort-controls');

            // Cache episodes for re-sorting and store parent
            cachedEpisodes = episodes;
            currentParent = parent;

            // Show episode sort controls
            sortControls.style.display = 'flex';

            clearElement(container);

            // Series header card (compact)
            const headerCard = createElement('div', { className: 'series-header-card' }, [
                parent.cover_url
                    ? createElement('img', { src: parent.cover_url, alt: '', className: 'series-cover' })
                    : createElement('div', { className: 'series-cover no-cover', textContent: 'üìª' }),
                createElement('div', { className: 'series-info' }, [
                    createElement('h3', { className: 'series-title', textContent: parent.title }),
                    createElement('p', { className: 'series-author', textContent: 'By ' + (parent.author || 'Unknown') }),
                    parent.description
                        ? createElement('p', { className: 'series-desc', textContent: parent.description.substring(0, 200) + (parent.description.length > 200 ? '...' : '') })
                        : null
                ]),
                createElement('div', { className: 'series-actions' }, [
                    createElement('button', {
                        className: 'download-all-btn',
                        title: 'Queue all episodes for download',
                        onClick: function() { queueAllEpisodes(cachedEpisodes); }
                    }, [
                        createElement('span', { textContent: '‚Üì Download All' })
                    ])
                ])
            ]);
            container.appendChild(headerCard);

            // Render the sorted episodes list
            renderEpisodesList(cachedEpisodes);
        }

        function renderEpisodesList(episodes) {
            // Find or create the episodes-list container (after header card)
            const container = document.getElementById('episode-list');
            let episodesList = container.querySelector('.episodes-list');

            if (!episodesList) {
                // Create if doesn't exist
                episodesList = createElement('div', { className: 'episodes-list' });
                container.appendChild(episodesList);
            } else {
                // Clear existing episodes
                clearElement(episodesList);
            }

            // Apply current sort
            const sortedEpisodes = sortEpisodes(episodes, episodeSortBy);

            if (sortedEpisodes.length === 0) {
                episodesList.appendChild(createEmptyState('üì≠', 'No episodes found'));
            } else {
                sortedEpisodes.forEach(function(ep, index) {
                    // For sorted display, show original index if sorting by something other than date-desc
                    episodesList.appendChild(createEpisodeCard(ep, index + 1));
                });
            }
        }

        function createEpisodeCard(ep, index) {
            // Determine action button based on status
            let actionBtn;
            if (ep.is_downloaded) {
                actionBtn = createElement('button', {
                    className: 'play-btn',
                    title: 'Play this episode',
                    onClick: function() { playEpisode(ep.asin); }
                }, [
                    createElement('span', { textContent: '‚ñ∂ Play' })
                ]);
            } else if (ep.download_requested) {
                actionBtn = createElement('div', { className: 'status-queued-small' }, [
                    createElement('span', { textContent: '‚è≥ Queued' })
                ]);
            } else {
                actionBtn = createElement('button', {
                    className: 'download-btn-small',
                    title: 'Queue for download',
                    onClick: function() { queueDownload(ep.asin); }
                }, [
                    createElement('span', { textContent: '‚Üì Download' })
                ]);
            }

            return createElement('div', { className: 'episode-card' + (ep.is_downloaded ? ' downloaded' : '') }, [
                createElement('div', { className: 'episode-number', textContent: '#' + index }),
                ep.cover_url
                    ? createElement('img', { src: ep.cover_url, alt: '', className: 'episode-thumb', loading: 'lazy' })
                    : null,
                createElement('div', { className: 'episode-info' }, [
                    createElement('span', { className: 'episode-title', textContent: ep.title }),
                    createElement('span', { className: 'episode-meta' }, [
                        ep.runtime_minutes ? formatDuration(ep.runtime_minutes) : '',
                        ep.release_date ? ' ‚Ä¢ ' + formatDate(ep.release_date) : ''
                    ].join(''))
                ]),
                createElement('div', { className: 'episode-action' }, [actionBtn])
            ]);
        }

        async function queueAllEpisodes(episodes) {
            const asinsToQueue = episodes
                .filter(function(ep) { return !ep.is_downloaded && !ep.download_requested; })
                .map(function(ep) { return ep.asin; });

            if (asinsToQueue.length === 0) {
                showQueueToast('All episodes already downloaded or queued', false);
                return;
            }

            try {
                const response = await fetch(API_BASE + '/download', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ asins: asinsToQueue })
                });
                const data = await response.json();
                showQueueToast(data.queued + ' episode(s) queued for download', false);
                // Refresh the view
                if (currentAsin) {
                    selectPeriodical(currentAsin, episodes.length);
                }
            } catch (error) {
                showQueueToast('Failed to queue episodes', true);
            }
        }

        function playEpisode(asin) {
            // Open player or navigate to audiobook in library
            // For now, just show a toast - the actual playback would need integration
            showQueueToast('Opening player for ' + asin + '...', false);
            // TODO: Implement actual playback - could redirect to library player
            // window.location.href = '/player.html?asin=' + encodeURIComponent(asin);
        }

        function renderPeriodicalDetails(item) {
            const container = document.getElementById('episode-list');
            const sortControls = document.getElementById('episode-sort-controls');

            // Hide episode sort controls for standalone items
            sortControls.style.display = 'none';
            cachedEpisodes = [];  // Clear episode cache

            clearElement(container);

            // Build details card (for standalone items or items without episodes)
            const detailsCard = createElement('div', { className: 'details-card' }, [
                // Cover and basic info
                createElement('div', { className: 'details-header' }, [
                    item.cover_url
                        ? createElement('img', {
                            src: item.cover_url,
                            alt: item.title,
                            className: 'details-cover'
                        })
                        : createElement('div', { className: 'details-cover no-cover', textContent: 'üìª' }),
                    createElement('div', { className: 'details-info' }, [
                        createElement('h3', { className: 'details-title', textContent: item.title }),
                        createElement('p', { className: 'details-author', textContent: 'By ' + (item.author || 'Unknown') }),
                        item.narrator
                            ? createElement('p', { className: 'details-narrator', textContent: 'Narrated by ' + item.narrator })
                            : null,
                        createElement('p', { className: 'details-type', textContent: (item.content_type || 'Periodical') + ' ‚Ä¢ ' + (item.category || 'Other') }),
                        item.runtime_minutes
                            ? createElement('p', { className: 'details-runtime', textContent: formatDuration(item.runtime_minutes) })
                            : null,
                        item.release_date
                            ? createElement('p', { className: 'details-date', textContent: 'Released: ' + formatDate(item.release_date) })
                            : null
                    ])
                ]),

                // Description
                item.description
                    ? createElement('div', { className: 'details-description' }, [
                        createElement('h4', { textContent: 'Description' }),
                        createElement('p', { textContent: item.description })
                    ])
                    : null,

                // Status & Actions
                createElement('div', { className: 'details-actions' }, [
                    item.is_downloaded
                        ? createElement('button', {
                            className: 'play-btn-large',
                            title: 'Play this item',
                            onClick: function() { playEpisode(item.asin); }
                        }, [
                            createElement('span', { className: 'play-icon', textContent: '‚ñ∂' }),
                            createElement('span', { textContent: 'Play Now' })
                        ])
                        : item.download_requested
                            ? createElement('div', { className: 'status-queued' }, [
                                createElement('span', { className: 'status-icon', textContent: '‚è≥' }),
                                createElement('span', { textContent: 'Queued for Download' })
                            ])
                            : createElement('button', {
                                className: 'download-btn',
                                title: 'Queue this item for download',
                                onClick: function() { queueDownload(item.asin); }
                            }, [
                                createElement('span', { className: 'download-icon', textContent: '‚Üì' }),
                                createElement('span', { textContent: 'Queue for Download' })
                            ])
                ]),

                // Metadata
                createElement('div', { className: 'details-meta' }, [
                    createElement('p', { textContent: 'ASIN: ' + item.asin }),
                    item.last_synced
                        ? createElement('p', { textContent: 'Last synced: ' + formatDate(item.last_synced) })
                        : null
                ])
            ]);

            container.appendChild(detailsCard);
        }

        // ========================================
        // Download Queue
        // ========================================
        async function queueDownload(asin) {
            try {
                const response = await fetch(API_BASE + '/download', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ asins: [asin] })
                });

                if (!response.ok) {
                    // Handle HTTP errors (4xx, 5xx)
                    let errorMsg = 'Server error: ' + response.status;
                    try {
                        const errorData = await response.json();
                        if (errorData.error) errorMsg = errorData.error;
                    } catch (e) { /* ignore JSON parse error */ }
                    throw new Error(errorMsg);
                }

                const data = await response.json();
                if (data.queued > 0) {
                    showQueueToast('Item queued for download', false);
                    // Refresh the details view
                    selectPeriodical(asin);
                    // Also refresh the list to update badges
                    loadPeriodicalsList();
                } else if (data.already_downloaded > 0) {
                    showQueueToast('Already downloaded', false);
                } else if (data.already_queued > 0) {
                    showQueueToast('Already in queue', false);
                } else {
                    // Unexpected response - show warning
                    showQueueToast('Unexpected response', true);
                }
            } catch (error) {
                console.error('Download queue error:', error);
                showQueueToast(error.message || 'Failed to queue download', true);
            }
        }

        function showQueueToast(message, isError) {
            const toast = document.getElementById('queue-toast');
            const text = document.getElementById('queue-text');
            text.textContent = message;
            toast.classList.toggle('error', isError);
            toast.style.display = 'flex';

            setTimeout(function() {
                toast.style.display = 'none';
            }, 4000);
        }

        // ========================================
        // Category Tabs
        // ========================================
        document.querySelectorAll('.category-tab').forEach(function(tab) {
            tab.addEventListener('click', function() {
                document.querySelectorAll('.category-tab').forEach(function(t) {
                    t.classList.remove('active');
                });
                tab.classList.add('active');
                currentCategory = tab.dataset.category;
                currentAsin = null;

                // Reset details panel
                document.getElementById('episode-panel-title').textContent = 'Select a publication';
                document.getElementById('episode-count').textContent = '';
                document.getElementById('episode-sort-controls').style.display = 'none';
                cachedEpisodes = [];
                const detailsContainer = document.getElementById('episode-list');
                clearElement(detailsContainer);
                detailsContainer.appendChild(createEmptyState('üì∞', 'Select a publication from the left to view details'));

                loadPeriodicalsList();
            });
        });

        // ========================================
        // Event Listeners
        // ========================================
        document.getElementById('refresh-btn').addEventListener('click', triggerSync);
        document.getElementById('queue-close').addEventListener('click', function() {
            document.getElementById('queue-toast').style.display = 'none';
        });

        // Sort button handlers
        document.querySelectorAll('.sort-btn').forEach(function(btn) {
            btn.addEventListener('click', function() {
                const sortBy = btn.dataset.sort;
                const panel = btn.dataset.panel;

                // Update active state for this panel's buttons
                btn.parentElement.querySelectorAll('.sort-btn').forEach(function(b) {
                    b.classList.remove('active');
                });
                btn.classList.add('active');

                if (panel === 'parent') {
                    parentSortBy = sortBy;
                    renderPeriodicalsList(cachedParents);
                } else if (panel === 'episode') {
                    episodeSortBy = sortBy;
                    renderEpisodesList(cachedEpisodes);
                }
            });
        });

        // ========================================
        // Utilities
        // ========================================
        function formatDate(dateStr) {
            if (!dateStr) return '';
            try {
                const date = new Date(dateStr);
                return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
            } catch (e) {
                return dateStr;
            }
        }

        function formatDuration(minutes) {
            if (!minutes) return '';
            if (minutes < 60) return minutes + ' minutes';
            const hours = Math.floor(minutes / 60);
            const mins = minutes % 60;
            if (mins === 0) return hours + ' hours';
            return hours + 'h ' + mins + 'm';
        }

        // ========================================
        // Initialize
        // ========================================
        document.addEventListener('DOMContentLoaded', function() {
            connectSSE();
            loadPeriodicalsList();
        });
    </script>
</body>
</html>
