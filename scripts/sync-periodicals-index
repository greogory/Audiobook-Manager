#!/bin/bash
# sync-periodicals-index - Sync Audible periodicals metadata to local database
#
# This script reads parent ASINs from the skip list, queries Audible for
# episode metadata, and updates the periodicals table.
#
# Run twice daily via systemd timer or manually with:
#   /opt/audiobooks/scripts/sync-periodicals-index
#
# Options:
#   --force     Re-sync all episodes (ignore last_synced)
#   --parent    Sync only specified parent ASIN
#   --verbose   Show detailed progress

set -euo pipefail

# Load config
source /usr/local/lib/audiobooks/audiobooks-config.sh

# Script config
SYNC_ID=$(uuidgen)
LOG_FILE="${AUDIOBOOKS_LOGS:-/var/log/audiobooks}/periodicals-sync.log"
SKIP_LIST="${AUDIOBOOKS_DATA}/audiobook-skip-list.txt"
DB="${AUDIOBOOKS_DATA}/audiobooks.db"
SSE_FIFO="/run/audiobooks/periodicals-sse"

# Known periodical parent ASINs with categories
declare -A PERIODICAL_CATEGORIES=(
    # Podcasts
    ["B08K56V638"]="podcast"    # Making Sense with Sam Harris
    ["B08D6TT96L"]="podcast"    # True Crime All The Time
    ["B08D6XHLLP"]="podcast"    # American Scandal
    ["B0BTJ8DDXD"]="podcast"    # Michelle Obama: The Light Podcast
    ["B08DF7FCXM"]="podcast"    # Stephen Fry's Victorian Secrets
    ["B09B496QVF"]="podcast"    # Stephen Fry's Edwardian Secrets
    ["B08MTSB77Z"]="podcast"    # Hell Cats
    ["B09881MMW7"]="podcast"    # Michael Caine: Gangs
    ["B08GC1VQ67"]="podcast"    # Heist with Michael Caine
    ["B0B4F665LR"]="podcast"    # KOZ
    ["B09T4NM5RF"]="podcast"    # Summer In Argyle
    ["B094NYF8Y1"]="podcast"    # The Importance of Being Earnest

    # News
    ["B002V9ZD4G"]="news"       # The New York Times Digest
    ["B01BX2GCW8"]="news"       # The New York Times Articles

    # Meditation
    ["B07G8DJNFV"]="meditation" # Everyday Meditation
    ["B07H38ZV58"]="meditation" # Sleep Better
    ["B07LBNN7KF"]="meditation" # 21 Days of Meditation
    ["B07MWCHSCC"]="meditation" # Morning Meditations
    ["B07NJ8PN92"]="meditation" # Reset Your Day
    ["B07NJ92WBN"]="meditation" # Find Your Bliss
)

# Parse arguments
FORCE_SYNC=false
SINGLE_PARENT=""
VERBOSE=false

while [[ $# -gt 0 ]]; do
    case $1 in
        --force) FORCE_SYNC=true; shift ;;
        --parent) SINGLE_PARENT="$2"; shift 2 ;;
        --verbose) VERBOSE=true; shift ;;
        *) echo "Unknown option: $1"; exit 1 ;;
    esac
done

log() {
    local msg="[$(date -Iseconds)] $1"
    echo "$msg" >> "$LOG_FILE"
    $VERBOSE && echo "$msg"
}

emit_sse() {
    # Send SSE event if FIFO exists
    if [[ -p "$SSE_FIFO" ]]; then
        echo "data: $1" > "$SSE_FIFO" 2>/dev/null || true
    fi
}

get_category() {
    local asin="$1"
    echo "${PERIODICAL_CATEGORIES[$asin]:-other}"
}

# Initialize sync status in database
init_sync() {
    sqlite3 "$DB" <<EOF
INSERT INTO periodicals_sync_status (sync_id, status, started_at)
VALUES ('$SYNC_ID', 'running', datetime('now'));
EOF
    log "Started sync $SYNC_ID"
    emit_sse '{"event":"sync_started","sync_id":"'"$SYNC_ID"'"}'
}

# Update sync status
update_sync_status() {
    local processed="$1"
    local total="$2"
    local episodes="$3"
    local new_eps="$4"

    sqlite3 "$DB" <<EOF
UPDATE periodicals_sync_status
SET processed_parents = $processed,
    total_parents = $total,
    total_episodes = $episodes,
    new_episodes = $new_eps
WHERE sync_id = '$SYNC_ID';
EOF
    emit_sse '{"event":"sync_progress","processed":'"$processed"',"total":'"$total"',"episodes":'"$episodes"',"new":'"$new_eps"'}'
}

# Complete sync
complete_sync() {
    local status="$1"
    local error="${2:-}"

    sqlite3 "$DB" <<EOF
UPDATE periodicals_sync_status
SET status = '$status',
    completed_at = datetime('now'),
    error_message = $([ -n "$error" ] && echo "'$error'" || echo "NULL")
WHERE sync_id = '$SYNC_ID';
EOF
    log "Completed sync $SYNC_ID with status: $status"
    emit_sse '{"event":"sync_completed","status":"'"$status"'"}'
}

# Sync a single parent ASIN
sync_parent() {
    local parent_asin="$1"
    local category
    category=$(get_category "$parent_asin")

    log "Syncing $parent_asin (category: $category)"

    # Get parent metadata
    local parent_data
    parent_data=$(audible api -p response_groups="product_desc,media,product_attrs" \
        "/1.0/catalog/products/$parent_asin" 2>/dev/null || echo "{}")

    if [[ -z "$parent_data" || "$parent_data" == "{}" ]]; then
        log "Warning: No data for $parent_asin"
        return 1
    fi

    # Extract parent info
    local title author cover_url
    title=$(echo "$parent_data" | jq -r '.product.title // "Unknown"' | sed "s/'/''/g")
    author=$(echo "$parent_data" | jq -r '.product.authors[0].name // "Unknown"' | sed "s/'/''/g")
    cover_url=$(echo "$parent_data" | jq -r '.product.product_images."500" // ""')

    # Upsert parent entry
    sqlite3 "$DB" <<EOF
INSERT INTO periodicals (parent_asin, child_asin, title, author, category, cover_url, last_synced)
VALUES ('$parent_asin', NULL, '$title', '$author', '$category', '$cover_url', datetime('now'))
ON CONFLICT(parent_asin, child_asin) DO UPDATE SET
    title = excluded.title,
    author = excluded.author,
    cover_url = excluded.cover_url,
    last_synced = excluded.last_synced;
EOF

    # Get children (episodes)
    local children_data
    children_data=$(audible api -p response_groups="product_desc,media" \
        "/1.0/catalog/products/$parent_asin/children?num_results=500" 2>/dev/null || echo "{}")

    local episode_count=0
    local new_count=0

    # Process each episode
    echo "$children_data" | jq -c '.products[]?' 2>/dev/null | while read -r episode; do
        local child_asin ep_title ep_num runtime release_date description

        child_asin=$(echo "$episode" | jq -r '.asin')
        ep_title=$(echo "$episode" | jq -r '.title // ""' | sed "s/'/''/g")
        ep_num=$(echo "$episode" | jq -r '.episode_number // null')
        runtime=$(echo "$episode" | jq -r '.runtime_length_min // null')
        release_date=$(echo "$episode" | jq -r '.release_date // null')
        description=$(echo "$episode" | jq -r '.publisher_summary // ""' | head -c 500 | sed "s/'/''/g")

        # Check if already exists
        local exists
        exists=$(sqlite3 "$DB" "SELECT 1 FROM periodicals WHERE parent_asin='$parent_asin' AND child_asin='$child_asin';")

        if [[ -z "$exists" ]]; then
            ((new_count++)) || true
        fi
        ((episode_count++)) || true

        # Upsert episode
        sqlite3 "$DB" <<EOF
INSERT INTO periodicals (
    parent_asin, child_asin, title, episode_title, episode_number,
    runtime_minutes, release_date, description, category, last_synced
) VALUES (
    '$parent_asin', '$child_asin', '$title', '$ep_title', $ep_num,
    $runtime, '$release_date', '$description', '$category', datetime('now')
)
ON CONFLICT(parent_asin, child_asin) DO UPDATE SET
    episode_title = excluded.episode_title,
    runtime_minutes = excluded.runtime_minutes,
    release_date = excluded.release_date,
    description = excluded.description,
    last_synced = excluded.last_synced;
EOF
    done

    log "Synced $parent_asin: $episode_count episodes ($new_count new)"
    echo "$episode_count $new_count"
}

# Main sync logic
main() {
    log "=== Starting periodicals sync ==="

    # Ensure database has schema
    if ! sqlite3 "$DB" "SELECT 1 FROM periodicals LIMIT 1;" 2>/dev/null; then
        log "Applying periodicals schema..."
        sqlite3 "$DB" < /opt/audiobooks/library/backend/migrations/006_periodicals.sql
    fi

    init_sync

    # Get list of periodical parent ASINs
    local parents=()
    if [[ -n "$SINGLE_PARENT" ]]; then
        parents=("$SINGLE_PARENT")
    else
        # Read from skip list, filter to known periodicals
        while IFS= read -r asin; do
            [[ -n "${PERIODICAL_CATEGORIES[$asin]:-}" ]] && parents+=("$asin")
        done < "$SKIP_LIST"
    fi

    local total=${#parents[@]}
    local processed=0
    local total_episodes=0
    local total_new=0

    log "Found $total periodical parents to sync"

    for parent in "${parents[@]}"; do
        ((processed++)) || true

        # Rate limit: 1 request per 2 seconds to avoid Audible throttling
        sleep 2

        local result
        result=$(sync_parent "$parent" 2>/dev/null) || continue

        local eps new
        eps=$(echo "$result" | awk '{print $1}')
        new=$(echo "$result" | awk '{print $2}')

        ((total_episodes += eps)) || true
        ((total_new += new)) || true

        update_sync_status "$processed" "$total" "$total_episodes" "$total_new"
    done

    complete_sync "completed"
    log "=== Sync complete: $total_episodes episodes ($total_new new) ==="
}

# Run with error handling
trap 'complete_sync "failed" "Unexpected error"' ERR
main "$@"
